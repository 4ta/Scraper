<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ã‚¿ãƒ¯ãƒ¼ãƒ‡ã‚£ãƒ•ã‚§ãƒ³ã‚¹</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #1a1a2e;
    color: #eee;
    font-family: 'Segoe UI', Tahoma, sans-serif;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    min-height: 100vh;
    padding: 20px;
    user-select: none;
  }
  #game-container {
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
    justify-content: center;
  }
  canvas {
    border: 2px solid #444;
    border-radius: 8px;
    cursor: crosshair;
    background: #0f3460;
  }
  #sidebar {
    width: 220px;
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  .panel {
    background: #16213e;
    border: 1px solid #333;
    border-radius: 8px;
    padding: 14px;
  }
  .panel h3 {
    font-size: 14px;
    color: #e94560;
    margin-bottom: 8px;
    border-bottom: 1px solid #333;
    padding-bottom: 6px;
  }
  .stat {
    display: flex;
    justify-content: space-between;
    margin: 4px 0;
    font-size: 13px;
  }
  .stat-value { color: #f0c040; font-weight: bold; }
  .tower-btn {
    display: flex;
    align-items: center;
    gap: 10px;
    width: 100%;
    padding: 10px;
    margin: 4px 0;
    background: #1a1a40;
    border: 2px solid #333;
    border-radius: 6px;
    color: #eee;
    cursor: pointer;
    font-size: 12px;
    transition: border-color 0.2s, background 0.2s;
  }
  .tower-btn:hover { border-color: #e94560; background: #222255; }
  .tower-btn.selected { border-color: #e94560; background: #2a1a3e; }
  .tower-btn .icon {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    flex-shrink: 0;
  }
  .tower-btn .info { text-align: left; }
  .tower-btn .name { font-weight: bold; font-size: 13px; }
  .tower-btn .cost { color: #f0c040; font-size: 11px; }
  .tower-btn .desc { color: #999; font-size: 10px; }
  #start-btn {
    width: 100%;
    padding: 12px;
    background: #e94560;
    border: none;
    border-radius: 6px;
    color: white;
    font-size: 15px;
    font-weight: bold;
    cursor: pointer;
    transition: background 0.2s;
  }
  #start-btn:hover { background: #c73652; }
  #start-btn:disabled { background: #555; cursor: default; }
  #message {
    text-align: center;
    font-size: 12px;
    color: #aaa;
    min-height: 36px;
    line-height: 1.4;
  }
  .upgrade-panel {
    display: none;
  }
  .upgrade-panel.visible {
    display: block;
  }
  #upgrade-btn, #sell-btn {
    padding: 8px;
    margin: 3px 0;
    width: 100%;
    border: none;
    border-radius: 4px;
    color: white;
    font-size: 12px;
    font-weight: bold;
    cursor: pointer;
  }
  #upgrade-btn { background: #2ecc71; }
  #upgrade-btn:hover { background: #27ae60; }
  #upgrade-btn:disabled { background: #555; cursor: default; }
  #sell-btn { background: #e67e22; }
  #sell-btn:hover { background: #d35400; }
</style>
</head>
<body>

<div id="game-container">
  <canvas id="game" width="640" height="640"></canvas>
  <div id="sidebar">
    <div class="panel">
      <h3>ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</h3>
      <div class="stat"><span>ãƒ©ã‚¤ãƒ•</span><span class="stat-value" id="lives">20</span></div>
      <div class="stat"><span>ã‚´ãƒ¼ãƒ«ãƒ‰</span><span class="stat-value" id="gold">100</span></div>
      <div class="stat"><span>ã‚¦ã‚§ãƒ¼ãƒ–</span><span class="stat-value" id="wave">0 / 0</span></div>
      <div class="stat"><span>ã‚¹ã‚³ã‚¢</span><span class="stat-value" id="score">0</span></div>
    </div>

    <div class="panel">
      <h3>ã‚¿ãƒ¯ãƒ¼é¸æŠ</h3>
      <button class="tower-btn" data-tower="basic">
        <div class="icon" style="background:#3498db;">ğŸ”«</div>
        <div class="info">
          <div class="name">ãƒ™ãƒ¼ã‚·ãƒƒã‚¯</div>
          <div class="cost">ğŸ’° 25</div>
          <div class="desc">ãƒãƒ©ãƒ³ã‚¹å‹</div>
        </div>
      </button>
      <button class="tower-btn" data-tower="sniper">
        <div class="icon" style="background:#9b59b6;">ğŸ¯</div>
        <div class="info">
          <div class="name">ã‚¹ãƒŠã‚¤ãƒ‘ãƒ¼</div>
          <div class="cost">ğŸ’° 50</div>
          <div class="desc">é«˜ç«åŠ›ãƒ»é…å°„</div>
        </div>
      </button>
      <button class="tower-btn" data-tower="splash">
        <div class="icon" style="background:#e74c3c;">ğŸ’¥</div>
        <div class="info">
          <div class="name">ã‚¹ãƒ—ãƒ©ãƒƒã‚·ãƒ¥</div>
          <div class="cost">ğŸ’° 75</div>
          <div class="desc">ç¯„å›²æ”»æ’ƒ</div>
        </div>
      </button>
      <button class="tower-btn" data-tower="freeze">
        <div class="icon" style="background:#00bcd4;">â„ï¸</div>
        <div class="info">
          <div class="name">ãƒ•ãƒªãƒ¼ã‚º</div>
          <div class="cost">ğŸ’° 40</div>
          <div class="desc">æ•µã‚’æ¸›é€Ÿ</div>
        </div>
      </button>
    </div>

    <div class="panel upgrade-panel" id="upgrade-panel">
      <h3>ã‚¿ãƒ¯ãƒ¼æƒ…å ±</h3>
      <div class="stat"><span>ã‚¿ã‚¤ãƒ—</span><span class="stat-value" id="sel-type">-</span></div>
      <div class="stat"><span>ãƒ¬ãƒ™ãƒ«</span><span class="stat-value" id="sel-level">-</span></div>
      <div class="stat"><span>ãƒ€ãƒ¡ãƒ¼ã‚¸</span><span class="stat-value" id="sel-dmg">-</span></div>
      <div class="stat"><span>å°„ç¨‹</span><span class="stat-value" id="sel-range">-</span></div>
      <button id="upgrade-btn">â¬† ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ (ğŸ’° --)</button>
      <button id="sell-btn">ğŸ’° å£²å´ (--G)</button>
    </div>

    <button id="start-btn">â–¶ ã‚¦ã‚§ãƒ¼ãƒ–é–‹å§‹</button>
    <div id="message">ã‚¿ãƒ¯ãƒ¼ã‚’é…ç½®ã—ã¦ã‚¦ã‚§ãƒ¼ãƒ–ã‚’é–‹å§‹ã—ã‚ˆã†ï¼</div>
  </div>
</div>

<script>
// ============================================================
// å®šæ•°ãƒ»è¨­å®š
// ============================================================
const COLS = 16, ROWS = 16, TILE = 40;
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// ãƒãƒƒãƒ—: 0=ç©ºåœ°, 1=é“, 2=ã‚¹ã‚¿ãƒ¼ãƒˆ, 3=ã‚´ãƒ¼ãƒ«
const MAP = [
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [2,1,1,1,0,0,0,0,0,0,0,1,1,1,1,0],
  [0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0],
  [0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0],
  [0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,0],
  [0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0],
  [0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0],
  [0,0,0,0,0,0,0,1,1,1,1,1,0,0,1,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],
  [0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0],
  [0,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0],
  [0,1,0,0,0,0,0,0,0,0,1,1,1,1,1,0],
  [0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,1,1,1,1,1,1,1,1,1,1,1,1,1,3,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
];

// çµŒè·¯ã‚’BFSã§è¨ˆç®—
function buildPath() {
  let start = null, end = null;
  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS; c++) {
      if (MAP[r][c] === 2) start = { r, c };
      if (MAP[r][c] === 3) end = { r, c };
    }
  const visited = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
  const prev = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
  const queue = [start];
  visited[start.r][start.c] = true;
  const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
  while (queue.length) {
    const cur = queue.shift();
    if (cur.r === end.r && cur.c === end.c) break;
    for (const [dr, dc] of dirs) {
      const nr = cur.r + dr, nc = cur.c + dc;
      if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && !visited[nr][nc] && MAP[nr][nc] !== 0) {
        visited[nr][nc] = true;
        prev[nr][nc] = cur;
        queue.push({ r: nr, c: nc });
      }
    }
  }
  const path = [];
  let cur = end;
  while (cur) {
    path.unshift({ x: cur.c * TILE + TILE / 2, y: cur.r * TILE + TILE / 2 });
    cur = prev[cur.r][cur.c];
  }
  return path;
}

const PATH = buildPath();

// ã‚¿ãƒ¯ãƒ¼å®šç¾©
const TOWER_DEFS = {
  basic:  { name: 'ãƒ™ãƒ¼ã‚·ãƒƒã‚¯', cost: 25, damage: 8,  range: 100, fireRate: 30, color: '#3498db', splashRadius: 0, slowFactor: 0 },
  sniper: { name: 'ã‚¹ãƒŠã‚¤ãƒ‘ãƒ¼', cost: 50, damage: 30, range: 180, fireRate: 80, color: '#9b59b6', splashRadius: 0, slowFactor: 0 },
  splash: { name: 'ã‚¹ãƒ—ãƒ©ãƒƒã‚·ãƒ¥', cost: 75, damage: 12, range: 110, fireRate: 50, color: '#e74c3c', splashRadius: 60, slowFactor: 0 },
  freeze: { name: 'ãƒ•ãƒªãƒ¼ã‚º', cost: 40, damage: 3,  range: 100, fireRate: 40, color: '#00bcd4', splashRadius: 0, slowFactor: 0.5 },
};

// æ•µã‚¿ã‚¤ãƒ—
const ENEMY_TYPES = {
  normal:  { hp: 40,  speed: 1.2, reward: 5,  color: '#2ecc71', radius: 8 },
  fast:    { hp: 25,  speed: 2.2, reward: 7,  color: '#f1c40f', radius: 6 },
  tank:    { hp: 120, speed: 0.7, reward: 15, color: '#e67e22', radius: 11 },
  boss:    { hp: 400, speed: 0.5, reward: 50, color: '#e74c3c', radius: 14 },
};

// ã‚¦ã‚§ãƒ¼ãƒ–å®šç¾©
function generateWaves(count) {
  const waves = [];
  for (let i = 0; i < count; i++) {
    const enemies = [];
    const n = 5 + i * 2;
    const hpMult = 1 + i * 0.3;
    for (let j = 0; j < n; j++) {
      let type = 'normal';
      if (i >= 2 && j % 4 === 0) type = 'fast';
      if (i >= 4 && j % 6 === 0) type = 'tank';
      if (i >= 7 && j === n - 1) type = 'boss';
      enemies.push({ type, hpMult });
    }
    waves.push({ enemies, spawnInterval: Math.max(20, 40 - i * 2) });
  }
  return waves;
}

const TOTAL_WAVES = 15;
const WAVES = generateWaves(TOTAL_WAVES);

// ============================================================
// ã‚²ãƒ¼ãƒ çŠ¶æ…‹
// ============================================================
let gold = 100, lives = 20, score = 0;
let currentWave = 0, waveActive = false, waveComplete = false;
let spawnTimer = 0, spawnIndex = 0;
let selectedTowerType = null;
let selectedTower = null;
let gameOver = false, gameWon = false;

const towers = [];
const enemies = [];
const bullets = [];
const particles = [];

// ============================================================
// UIæ›´æ–°
// ============================================================
const elLives = document.getElementById('lives');
const elGold = document.getElementById('gold');
const elWave = document.getElementById('wave');
const elScore = document.getElementById('score');
const elMessage = document.getElementById('message');
const elStartBtn = document.getElementById('start-btn');
const elUpgradePanel = document.getElementById('upgrade-panel');
const elSelType = document.getElementById('sel-type');
const elSelLevel = document.getElementById('sel-level');
const elSelDmg = document.getElementById('sel-dmg');
const elSelRange = document.getElementById('sel-range');
const elUpgradeBtn = document.getElementById('upgrade-btn');
const elSellBtn = document.getElementById('sell-btn');

function updateUI() {
  elLives.textContent = lives;
  elGold.textContent = gold;
  elWave.textContent = `${currentWave} / ${TOTAL_WAVES}`;
  elScore.textContent = score;

  if (selectedTower) {
    elUpgradePanel.classList.add('visible');
    const def = TOWER_DEFS[selectedTower.type];
    elSelType.textContent = def.name;
    elSelLevel.textContent = selectedTower.level;
    elSelDmg.textContent = Math.round(selectedTower.damage);
    elSelRange.textContent = Math.round(selectedTower.range);
    const upgCost = getUpgradeCost(selectedTower);
    if (selectedTower.level >= 5) {
      elUpgradeBtn.textContent = 'æœ€å¤§ãƒ¬ãƒ™ãƒ«';
      elUpgradeBtn.disabled = true;
    } else {
      elUpgradeBtn.textContent = `â¬† ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ (ğŸ’° ${upgCost})`;
      elUpgradeBtn.disabled = gold < upgCost;
    }
    const sellValue = getSellValue(selectedTower);
    elSellBtn.textContent = `ğŸ’° å£²å´ (${sellValue}G)`;
  } else {
    elUpgradePanel.classList.remove('visible');
  }
}

function setMessage(msg) { elMessage.textContent = msg; }

function getUpgradeCost(tower) {
  return Math.round(TOWER_DEFS[tower.type].cost * 0.6 * tower.level);
}

function getSellValue(tower) {
  return Math.round(tower.totalSpent * 0.6);
}

// ============================================================
// ã‚¿ãƒ¯ãƒ¼ãƒœã‚¿ãƒ³
// ============================================================
document.querySelectorAll('.tower-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const type = btn.dataset.tower;
    if (selectedTowerType === type) {
      selectedTowerType = null;
      btn.classList.remove('selected');
    } else {
      document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
      selectedTowerType = type;
      btn.classList.add('selected');
      selectedTower = null;
    }
    updateUI();
  });
});

// ã‚¦ã‚§ãƒ¼ãƒ–é–‹å§‹ãƒœã‚¿ãƒ³
elStartBtn.addEventListener('click', () => {
  if (waveActive || gameOver || gameWon) return;
  if (currentWave >= TOTAL_WAVES) return;
  currentWave++;
  waveActive = true;
  spawnTimer = 0;
  spawnIndex = 0;
  elStartBtn.disabled = true;
  setMessage(`ã‚¦ã‚§ãƒ¼ãƒ– ${currentWave} é–‹å§‹ï¼`);
  updateUI();
});

// ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³
elUpgradeBtn.addEventListener('click', () => {
  if (!selectedTower || selectedTower.level >= 5) return;
  const cost = getUpgradeCost(selectedTower);
  if (gold < cost) return;
  gold -= cost;
  selectedTower.totalSpent += cost;
  selectedTower.level++;
  selectedTower.damage *= 1.3;
  selectedTower.range *= 1.08;
  selectedTower.fireRate = Math.max(10, selectedTower.fireRate - 3);
  updateUI();
});

// å£²å´ãƒœã‚¿ãƒ³
elSellBtn.addEventListener('click', () => {
  if (!selectedTower) return;
  gold += getSellValue(selectedTower);
  const idx = towers.indexOf(selectedTower);
  if (idx >= 0) towers.splice(idx, 1);
  selectedTower = null;
  updateUI();
});

// ============================================================
// ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¯ãƒªãƒƒã‚¯
// ============================================================
canvas.addEventListener('click', (e) => {
  if (gameOver || gameWon) {
    // ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ
    restartGame();
    return;
  }
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const col = Math.floor(mx / TILE);
  const row = Math.floor(my / TILE);

  // æ—¢å­˜ã‚¿ãƒ¯ãƒ¼é¸æŠ
  const clicked = towers.find(t => t.col === col && t.row === row);
  if (clicked) {
    selectedTower = clicked;
    selectedTowerType = null;
    document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
    updateUI();
    return;
  }

  // ã‚¿ãƒ¯ãƒ¼é…ç½®
  if (selectedTowerType) {
    if (MAP[row][col] !== 0) {
      setMessage('é“ã®ä¸Šã«ã¯é…ç½®ã§ãã¾ã›ã‚“ï¼');
      return;
    }
    if (towers.some(t => t.col === col && t.row === row)) {
      setMessage('æ—¢ã«ã‚¿ãƒ¯ãƒ¼ãŒã‚ã‚Šã¾ã™ï¼');
      return;
    }
    const def = TOWER_DEFS[selectedTowerType];
    if (gold < def.cost) {
      setMessage('ã‚´ãƒ¼ãƒ«ãƒ‰ãŒè¶³ã‚Šã¾ã›ã‚“ï¼');
      return;
    }
    gold -= def.cost;
    towers.push({
      type: selectedTowerType,
      col, row,
      x: col * TILE + TILE / 2,
      y: row * TILE + TILE / 2,
      damage: def.damage,
      range: def.range,
      fireRate: def.fireRate,
      cooldown: 0,
      level: 1,
      totalSpent: def.cost,
      angle: 0,
    });
    setMessage(`${def.name}ã‚¿ãƒ¯ãƒ¼ã‚’é…ç½®ï¼`);
    selectedTower = null;
    updateUI();
    return;
  }

  // ä½•ã‚‚é¸æŠã—ã¦ã„ãªã‘ã‚Œã°è§£é™¤
  selectedTower = null;
  updateUI();
});

// ãƒã‚¦ã‚¹ã‚ªãƒ¼ãƒãƒ¼
let hoverCol = -1, hoverRow = -1;
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  hoverCol = Math.floor((e.clientX - rect.left) / TILE);
  hoverRow = Math.floor((e.clientY - rect.top) / TILE);
});

// ============================================================
// æ•µã‚¹ãƒãƒ¼ãƒ³
// ============================================================
function spawnEnemy(typeKey, hpMult) {
  const def = ENEMY_TYPES[typeKey];
  const start = PATH[0];
  enemies.push({
    type: typeKey,
    x: start.x, y: start.y,
    hp: def.hp * hpMult,
    maxHp: def.hp * hpMult,
    speed: def.speed,
    baseSpeed: def.speed,
    color: def.color,
    radius: def.radius,
    reward: def.reward,
    pathIndex: 0,
    slowTimer: 0,
  });
}

// ============================================================
// ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯æ›´æ–°
// ============================================================
function update() {
  if (gameOver || gameWon) return;

  // ã‚¦ã‚§ãƒ¼ãƒ–ã‚¹ãƒãƒ¼ãƒ³
  if (waveActive && currentWave > 0) {
    const waveDef = WAVES[currentWave - 1];
    if (spawnIndex < waveDef.enemies.length) {
      spawnTimer++;
      if (spawnTimer >= waveDef.spawnInterval) {
        spawnTimer = 0;
        const e = waveDef.enemies[spawnIndex];
        spawnEnemy(e.type, e.hpMult);
        spawnIndex++;
      }
    } else if (enemies.length === 0) {
      waveActive = false;
      elStartBtn.disabled = false;
      if (currentWave >= TOTAL_WAVES) {
        gameWon = true;
        setMessage('ğŸ‰ å…¨ã‚¦ã‚§ãƒ¼ãƒ–ã‚¯ãƒªã‚¢ï¼ãŠã‚ã§ã¨ã†ï¼ã‚¯ãƒªãƒƒã‚¯ã§ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ');
      } else {
        setMessage(`ã‚¦ã‚§ãƒ¼ãƒ– ${currentWave} ã‚¯ãƒªã‚¢ï¼æ¬¡ã®ã‚¦ã‚§ãƒ¼ãƒ–ã«å‚™ãˆã‚ˆã†`);
      }
      updateUI();
    }
  }

  // æ•µç§»å‹•
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    // ã‚¹ãƒ­ãƒ¼å‡¦ç†
    if (e.slowTimer > 0) {
      e.slowTimer--;
      e.speed = e.baseSpeed * 0.4;
    } else {
      e.speed = e.baseSpeed;
    }
    if (e.pathIndex < PATH.length) {
      const target = PATH[e.pathIndex];
      const dx = target.x - e.x, dy = target.y - e.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < e.speed * 2) {
        e.pathIndex++;
      } else {
        e.x += (dx / dist) * e.speed;
        e.y += (dy / dist) * e.speed;
      }
    }
    // ã‚´ãƒ¼ãƒ«åˆ°é”
    if (e.pathIndex >= PATH.length) {
      enemies.splice(i, 1);
      lives--;
      if (lives <= 0) {
        lives = 0;
        gameOver = true;
        setMessage('ğŸ’€ ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼ã‚¯ãƒªãƒƒã‚¯ã§ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ');
      }
      updateUI();
    }
  }

  // ã‚¿ãƒ¯ãƒ¼æ”»æ’ƒ
  for (const t of towers) {
    if (t.cooldown > 0) { t.cooldown--; continue; }
    const def = TOWER_DEFS[t.type];
    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ¤œç´¢ï¼ˆæœ€ã‚‚é€²ã‚“ã§ã„ã‚‹æ•µå„ªå…ˆï¼‰
    let target = null;
    let bestProgress = -1;
    for (const e of enemies) {
      const dx = e.x - t.x, dy = e.y - t.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist <= t.range && e.pathIndex > bestProgress) {
        bestProgress = e.pathIndex;
        target = e;
      }
    }
    if (target) {
      t.cooldown = t.fireRate;
      t.angle = Math.atan2(target.y - t.y, target.x - t.x);
      bullets.push({
        x: t.x, y: t.y,
        targetId: enemies.indexOf(target),
        damage: t.damage,
        speed: 5,
        color: def.color,
        splashRadius: def.splashRadius,
        slowFactor: def.slowFactor,
        towerType: t.type,
      });
    }
  }

  // å¼¾ç§»å‹•
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    const target = enemies[b.targetId];
    if (!target) { bullets.splice(i, 1); continue; }
    const dx = target.x - b.x, dy = target.y - b.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < b.speed + target.radius) {
      // ãƒ’ãƒƒãƒˆ
      if (b.splashRadius > 0) {
        // ã‚¹ãƒ—ãƒ©ãƒƒã‚·ãƒ¥ãƒ€ãƒ¡ãƒ¼ã‚¸
        for (const e of enemies) {
          const sdx = e.x - target.x, sdy = e.y - target.y;
          if (Math.sqrt(sdx * sdx + sdy * sdy) <= b.splashRadius) {
            e.hp -= b.damage;
            spawnParticles(e.x, e.y, '#ff6644', 3);
          }
        }
        spawnParticles(target.x, target.y, '#ff4422', 8);
      } else {
        target.hp -= b.damage;
        spawnParticles(target.x, target.y, b.color, 4);
      }
      // ã‚¹ãƒ­ãƒ¼åŠ¹æœ
      if (b.slowFactor > 0) {
        target.slowTimer = 60;
      }
      bullets.splice(i, 1);
    } else {
      b.x += (dx / dist) * b.speed;
      b.y += (dy / dist) * b.speed;
    }
  }

  // æ•µæ­»äº¡åˆ¤å®š
  for (let i = enemies.length - 1; i >= 0; i--) {
    if (enemies[i].hp <= 0) {
      const e = enemies[i];
      gold += e.reward;
      score += e.reward * 10;
      spawnParticles(e.x, e.y, e.color, 10);
      enemies.splice(i, 1);
      updateUI();
    }
  }

  // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life--;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function spawnParticles(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 1 + Math.random() * 2;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      color,
      life: 15 + Math.random() * 10,
      maxLife: 25,
      radius: 2 + Math.random() * 2,
    });
  }
}

// ============================================================
// æç”»
// ============================================================
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // ãƒãƒƒãƒ—æç”»
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const x = c * TILE, y = r * TILE;
      if (MAP[r][c] === 0) {
        ctx.fillStyle = (r + c) % 2 === 0 ? '#1a3a2a' : '#1e4030';
      } else if (MAP[r][c] === 2) {
        ctx.fillStyle = '#2ecc71';
      } else if (MAP[r][c] === 3) {
        ctx.fillStyle = '#e74c3c';
      } else {
        ctx.fillStyle = (r + c) % 2 === 0 ? '#3d2b1f' : '#4a3628';
      }
      ctx.fillRect(x, y, TILE, TILE);
      // ã‚°ãƒªãƒƒãƒ‰ç·š
      ctx.strokeStyle = 'rgba(255,255,255,0.03)';
      ctx.strokeRect(x, y, TILE, TILE);
    }
  }

  // ãƒ‘ã‚¹æ–¹å‘çŸ¢å°ï¼ˆè–„ãï¼‰
  ctx.globalAlpha = 0.15;
  ctx.fillStyle = '#fff';
  for (let i = 0; i < PATH.length - 1; i += 3) {
    const p = PATH[i], n = PATH[i + 1];
    const angle = Math.atan2(n.y - p.y, n.x - p.x);
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.rotate(angle);
    ctx.beginPath();
    ctx.moveTo(6, 0);
    ctx.lineTo(-4, -4);
    ctx.lineTo(-4, 4);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }
  ctx.globalAlpha = 1;

  // ã‚¿ãƒ¯ãƒ¼å°„ç¨‹ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆãƒ›ãƒãƒ¼ä¸­ï¼‰
  if (selectedTowerType && hoverRow >= 0 && hoverCol >= 0 && hoverRow < ROWS && hoverCol < COLS) {
    if (MAP[hoverRow][hoverCol] === 0 && !towers.some(t => t.col === hoverCol && t.row === hoverRow)) {
      const def = TOWER_DEFS[selectedTowerType];
      const cx = hoverCol * TILE + TILE / 2;
      const cy = hoverRow * TILE + TILE / 2;
      ctx.beginPath();
      ctx.arc(cx, cy, def.range, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.stroke();
      // ã‚´ãƒ¼ã‚¹ãƒˆã‚¿ãƒ¯ãƒ¼
      ctx.globalAlpha = 0.5;
      drawTowerAt(cx, cy, def.color, 0);
      ctx.globalAlpha = 1;
    }
  }

  // é¸æŠä¸­ã‚¿ãƒ¯ãƒ¼ã®å°„ç¨‹
  if (selectedTower) {
    ctx.beginPath();
    ctx.arc(selectedTower.x, selectedTower.y, selectedTower.range, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(233,69,96,0.5)';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.lineWidth = 1;
  }

  // ã‚¿ãƒ¯ãƒ¼æç”»
  for (const t of towers) {
    drawTowerAt(t.x, t.y, TOWER_DEFS[t.type].color, t.angle, t.level);
    // é¸æŠãƒã‚¤ãƒ©ã‚¤ãƒˆ
    if (t === selectedTower) {
      ctx.strokeStyle = '#e94560';
      ctx.lineWidth = 2;
      ctx.strokeRect(t.col * TILE + 2, t.row * TILE + 2, TILE - 4, TILE - 4);
      ctx.lineWidth = 1;
    }
  }

  // æ•µæç”»
  for (const e of enemies) {
    // æœ¬ä½“
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
    ctx.fillStyle = e.slowTimer > 0 ? '#87ceeb' : e.color;
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
    ctx.stroke();

    // HPãƒãƒ¼
    const barW = e.radius * 2.5;
    const barH = 3;
    const barX = e.x - barW / 2;
    const barY = e.y - e.radius - 7;
    ctx.fillStyle = '#333';
    ctx.fillRect(barX, barY, barW, barH);
    const hpRatio = e.hp / e.maxHp;
    ctx.fillStyle = hpRatio > 0.5 ? '#2ecc71' : hpRatio > 0.25 ? '#f1c40f' : '#e74c3c';
    ctx.fillRect(barX, barY, barW * hpRatio, barH);
  }

  // å¼¾æç”»
  for (const b of bullets) {
    ctx.beginPath();
    ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
    ctx.fillStyle = b.color;
    ctx.fill();
  }

  // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
  for (const p of particles) {
    ctx.globalAlpha = p.life / p.maxLife;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.radius * (p.life / p.maxLife), 0, Math.PI * 2);
    ctx.fillStyle = p.color;
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ / ã‚¯ãƒªã‚¢è¡¨ç¤º
  if (gameOver || gameWon) {
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = gameWon ? '#2ecc71' : '#e74c3c';
    ctx.font = 'bold 40px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(gameWon ? 'ğŸ‰ VICTORY!' : 'ğŸ’€ GAME OVER', canvas.width / 2, canvas.height / 2 - 20);
    ctx.fillStyle = '#eee';
    ctx.font = '20px sans-serif';
    ctx.fillText(`ã‚¹ã‚³ã‚¢: ${score}`, canvas.width / 2, canvas.height / 2 + 20);
    ctx.font = '16px sans-serif';
    ctx.fillText('ã‚¯ãƒªãƒƒã‚¯ã§ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ', canvas.width / 2, canvas.height / 2 + 55);
    ctx.textAlign = 'left';
  }
}

function drawTowerAt(x, y, color, angle, level) {
  // ãƒ™ãƒ¼ã‚¹
  ctx.beginPath();
  ctx.arc(x, y, 14, 0, Math.PI * 2);
  ctx.fillStyle = color;
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.stroke();
  // ç ²èº«
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  ctx.fillStyle = '#ddd';
  ctx.fillRect(0, -3, 16, 6);
  ctx.restore();
  // ãƒ¬ãƒ™ãƒ«è¡¨ç¤º
  if (level && level > 1) {
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 9px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('â˜…'.repeat(Math.min(level - 1, 4)), x, y + 4);
    ctx.textAlign = 'left';
  }
}

// ============================================================
// ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ
// ============================================================
function restartGame() {
  gold = 100; lives = 20; score = 0;
  currentWave = 0; waveActive = false;
  spawnTimer = 0; spawnIndex = 0;
  selectedTowerType = null; selectedTower = null;
  gameOver = false; gameWon = false;
  towers.length = 0; enemies.length = 0; bullets.length = 0; particles.length = 0;
  elStartBtn.disabled = false;
  document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
  setMessage('ã‚¿ãƒ¯ãƒ¼ã‚’é…ç½®ã—ã¦ã‚¦ã‚§ãƒ¼ãƒ–ã‚’é–‹å§‹ã—ã‚ˆã†ï¼');
  updateUI();
}

// ============================================================
// ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—
// ============================================================
function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

updateUI();
gameLoop();
</script>
</body>
</html>
